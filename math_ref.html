<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>5. Mathematical Reference &#8212; MSlice 2.9 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxdoc.css?v=87629129" />
    <script src="_static/documentation_options.js?v=e7305a5c"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="4. Command Line Interface" href="cli.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="cli.html" title="4. Command Line Interface"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">MSlice 2.9 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5. </span>Mathematical Reference</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="mathematical-reference">
<span id="id1"></span><h1><span class="section-number">5. </span>Mathematical Reference<a class="headerlink" href="#mathematical-reference" title="Link to this heading">¶</a></h1>
<p>This page describes the mathematical operations behind the <code class="docutils literal notranslate"><span class="pre">Slice</span></code> and <code class="docutils literal notranslate"><span class="pre">Cut</span></code> operations of MSlice</p>
<p>In general, MSlice handles “reduced” (processed) inelastic neutron scattering data which has been
binned (histogrammed) in energy transfer for each detector / position-sensitive-detector (PSD) element.
We will use the terminology of the <a class="reference external" href="https://pace-neutrons.github.io/Horace">Horace</a> program and
refer to these energy-detector-element bins as “pixels”.</p>
<p>Since the detector elements are in the laboratory coordinates, but we often want to plot the data
in reciprocal space, a coordinate transformation is needed.
This means that the input and output binning grids of the data will not be axis aligned, and will
instead look something like this:</p>
<a class="reference internal image-reference" href="_images/rebin_grids.svg" id="grid-figure"><img alt="_images/rebin_grids.svg" id="grid-figure" src="_images/rebin_grids.svg" style="width: 600px;" />
</a>
<p>Where the square red grid represents the target (output) bins, and the slanted green grids
(parallelograms) represents the original bins (“pixels”).
As discussed in the <a class="reference internal" href="quickstart.html#psd-and-non-psd-modes"><span class="std std-ref">PSD and non-PSD modes</span></a> section, MSlice makes a distinction between
<strong>PSD</strong> (fine green grid) and <strong>non-PSD</strong> (coarser green grid) data.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">Slice</span></code> refers to a rebin into a two dimensional output, whilst a <code class="docutils literal notranslate"><span class="pre">Cut</span></code> is a rebin _or_
integration into a one dimensional output.
For each type of data (<strong>PSD</strong> and <strong>non-PSD</strong>) we will describe each operation in turn.</p>
<section id="psd-slice">
<h2><span class="section-number">5.1. </span>PSD Slice<a class="headerlink" href="#psd-slice" title="Link to this heading">¶</a></h2>
<p>For <strong>PSD</strong> data, MSlice uses <em>centre-point rebinning</em>, treating each input bin (“pixel”) as a
point and summing the full signal of each pixel whose centres lie within an output bin
(illustrated in the image by the darker green shading in top left, with dots marking centres).
Thus the output signal in the <span class="math">(i,j)</span>th bin, <span class="math">Y_{ij}</span>, is:</p>
<div class="math">
<p><span class="math">Y_{ij} = \frac{1}{N_{kl}} \sum_{kl} y_{kl}</span></p>
</div><p>where <span class="math">y_{kl}</span> is the input signal in the input <span class="math">(k,l)</span>th bin
and the sum runs over the <span class="math">N_{kl}</span> number of bins whose centres lie within the
boundaries of the <span class="math">(i,j)</span>th output bin.</p>
<p>The above expression uses the <code class="docutils literal notranslate"><span class="pre">NumEventsNormalization</span></code> convention of Mantid which is the
same as that adopted by the <a class="reference external" href="https://pace-neutrons.github.io/Horace">Horace</a> program.
The error values are considered to be standard deviations and are summed in quadrature.</p>
</section>
<section id="psd-cut">
<h2><span class="section-number">5.2. </span>PSD Cut<a class="headerlink" href="#psd-cut" title="Link to this heading">¶</a></h2>
<p>Since MSlice allows users to specify bins in the non-integrating direction which are not
necessarily aligned with respect to the original data, a rebinning step as described above
is needed for the <code class="docutils literal notranslate"><span class="pre">Cut</span></code> operation too.</p>
<p>This leads to the two types of behaviour (“algorithms”) for the <code class="docutils literal notranslate"><span class="pre">Cut</span></code> operation described
in the <a class="reference internal" href="cutting.html#cutting-algorithms"><span class="std std-ref">Cutting Algorithms</span></a> section:</p>
<ul class="simple">
<li><p>The default <code class="docutils literal notranslate"><span class="pre">Rebin</span></code> method just uses the rebinning described above with one axis having
only a single bin.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Integration</span></code> method first rebins the data as described above with the integration axis
divided into <span class="math">N_{\mathrm{int}} =</span> 100 bins.
It then calls the relevant Mantid algorithm
(<a class="reference external" href="https://docs.mantidproject.org/nightly/algorithms/IntegrateMDHistoWorkspace-v1.html">IntegrateMDHistoWorkspace</a>)
to integrate (sums the signal) in those 100 bins.</p></li>
</ul>
<p>Taking the <span class="math">j</span> index to be over the integration axis, the integrated <code class="docutils literal notranslate"><span class="pre">Cut</span></code> signal
<span class="math">C_i</span> is then given by:</p>
<div class="math">
<p><span class="math">C_i^{\mathrm{integration}} = w_i \sum_{j \in \mathcal{D}} Y_{ij}</span></p>
</div><p>where the index <span class="math">j</span> only runs over regions with data <span class="math">\mathcal{D}</span>, and the width
<span class="math">w_i = \sum_{j \in \mathcal{D}} w_{ij}</span> where <span class="math">w_{ij}</span> is the width in the
<span class="math">j</span>th direction of the <span class="math">(i,j)</span>th bin.</p>
<p>Note that the equivalent expression for a <code class="docutils literal notranslate"><span class="pre">Rebin</span></code> cut is simply:</p>
<div class="math">
<p><span class="math">C_i^{\mathrm{rebin}} = \sum_{j \in \mathcal{F}} Y_{ij}</span></p>
</div><p>where now the index <span class="math">j</span> runs over the full integration range <span class="math">\mathcal{F}</span>.
The difference is thus a coordinate-dependent weighting factor <span class="math">w_i</span>.
If the integration range <em>does not include regions without data</em> (e.g. <span class="math">\mathcal{D} \equiv \mathcal{F}</span>)
then all the <span class="math">w_i</span> will be equal to the full integration width and the difference between
<span class="math">C_i^{\mathrm{integration}}</span> and <span class="math">C_i^{\mathrm{rebin}}</span> is a constant.</p>
<p>However, if the integration range covers region with no data (e.g. beyond the kinematic limits)
then the two cuts <em>may</em> look very different because <span class="math">C_i^{\mathrm{integration}}</span> will weight
regions with data more heavily than regions without data.</p>
</section>
<section id="non-psd-slice">
<h2><span class="section-number">5.3. </span>Non-PSD Slice<a class="headerlink" href="#non-psd-slice" title="Link to this heading">¶</a></h2>
<p>For <strong>non-PSD</strong> data, MSlice uses <em>fractional rebinning</em>, where it first calculates the
overlap area between the input and output bins, and then sums only the fraction of the
signal of the input bins which overlaps the output bin.</p>
<p>The output signal is computed as:</p>
<div class="math">
<p><span class="math">Y_{ij} = \left. \sum_{kl} y_{kl} f_{kl} \right/ \sum_{kl} f_{kl}</span></p>
</div><p>and the output uncertainty as:</p>
<div class="math">
<p><span class="math">E_{ij} = \left. \sqrt{\sum_{kl} e^2_{kl} f_{kl}} \right/ \sum_{kl} f_{kl}</span></p>
</div><p>where <span class="math">f_{kl}</span> is the fractional overlap of the input <span class="math">(k,l)</span>th bin with
the output <span class="math">(i,j)</span>th bin.</p>
<p>This is illustrated in the <a class="reference internal" href="#grid-figure"><span class="std std-ref">figure</span></a> at the start of the page by the square on the right
hand side with blue triangular and orange quadrilateral shaded regions.
The blue and orange shading illustrates the fractional overlap areas which weights
the signal in the top left and top right input bins (large parallelograms) respectively.</p>
</section>
<section id="non-psd-cuts">
<h2><span class="section-number">5.4. </span>Non-PSD Cuts<a class="headerlink" href="#non-psd-cuts" title="Link to this heading">¶</a></h2>
<p>Like for <strong>PSD</strong> data, there are two <code class="docutils literal notranslate"><span class="pre">Cut</span></code> “algorithms” for <strong>non-PSD</strong> data also.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Rebin</span></code> cut algorithm performs the same operation described in the previous section
but with a single bin in the integration axis, yielding</p>
<div class="math">
<p><span class="math">C_i^{\mathrm{rebin}} = \left. \sum_{j \in \mathcal{F}} Y_{ij} \right/ \sum_{j \in \mathcal{F}} F_{ij}</span></p>
</div><p>where <span class="math">F_{ij} = \sum_{kl} f_{kl}</span>, and <span class="math">\mathcal{F}</span> indicates the full integration range.</p>
<p>In order to support rebinning in the non-integration axis, the <code class="docutils literal notranslate"><span class="pre">Integration</span></code> algorithm
first rebins the data into the desired bins in the non-integration axis,
and 100 bins in the integration axis and then sums them as:</p>
<div class="math">
<p><span class="math">C_i^{\mathrm{integration}} = \left. N_i \sum_{j \in \mathcal{F}} Y_{ij} w_{ij} \right/ \sum_{j \in \mathcal{F}} F_{ij}</span></p>
</div><p>where <span class="math">N_i = \sum_{j \in \mathcal{D}} 1</span> is the number of <span class="math">j</span> bins at a given
<span class="math">i</span> <em>with non-zero fraction</em> (e.g. if the integration contains only regions with data
then <span class="math">N_i</span> = 100, otherwise <span class="math">N_i</span> will be less),
and <span class="math">w_{ij}</span> is the width along the <span class="math">j</span>th axis of the <span class="math">(i,j)</span>th bin.
The <span class="math">N_i</span> normalisation is needed because in the limiting case where all the fractions
<span class="math">F_{ij}</span> are unity, the denominator would be <span class="math">N_i</span>, so we recover the usual
expression for integrating over a distribution.
Note that as previously, <span class="math">\mathcal{D}</span> indicates the region within the integration
range with data (in this case equivalent to regions with non-zero fractions).</p>
<p>Like with the <strong>PSD</strong> case there is thus an <span class="math">i</span> dependent scaling factor <span class="math">N_i w</span>
(assuming all the bins have the same width) between <code class="docutils literal notranslate"><span class="pre">Cuts</span></code> computed using the <code class="docutils literal notranslate"><span class="pre">Rebin</span></code> or
<code class="docutils literal notranslate"><span class="pre">Integration</span></code> algorithm.
This scaling factor is a constant if the integration range includes only regions with data
(e.g. <span class="math">\mathcal{D} \equiv \mathcal{F}</span>), but will not be constant if the integration
overlaps regions without data.</p>
<p>The difference is illustrated below:</p>
<img alt="_images/rebin_cuts.png" src="_images/rebin_cuts.png" />
<p>The cuts have been normalised to the peak intensity so that the constant scaling factor between
the two algorithms factorises out.
In the top cut, integrating over <span class="math">6 \leq |Q| &lt; 8 \mathrm{\AA}^{-1}</span> there are no regions
without data so the two cuts are equivalent except for a constant scaling factor.
In the bottom cut, integrating over <span class="math">8 \leq |Q| &lt; 10 \mathrm{\AA}^{-1}</span> there is a large
region with no data, so now cuts from the two techniques differ markedly.
At <span class="math">E&lt;0</span> meV Where the data covers the full integration range, we have <span class="math">N_i</span> = 100
and the two cuts are equivalent.
As <span class="math">E</span> increases, <span class="math">N_i</span> decreases until at around 20 meV, it is <span class="math">N_i</span> = 50,
and we see that at that point the (normalised) <code class="docutils literal notranslate"><span class="pre">Integration</span></code> cut is half the intensity of
the (normalised) <code class="docutils literal notranslate"><span class="pre">Rebin</span></code> cut.</p>
</section>
<section id="a-note-on-units">
<h2><span class="section-number">5.5. </span>A note on units<a class="headerlink" href="#a-note-on-units" title="Link to this heading">¶</a></h2>
<p>One advantage of inelastic neutron scattering over other techniques is that it is (relatively)
easy to normalise the measured data to absolute units.
At the ISIS Neutron and Muon Source if this normalisation is done, then the signal will be in
units of [milibarns per steradian per meV per formula unit] or [mb/sr/meV/f.u.].</p>
<p>An <code class="docutils literal notranslate"><span class="pre">Integration</span></code> over energy would then yield a differential cross-section in [mb/sr/f.u.],
whereas a <code class="docutils literal notranslate"><span class="pre">Rebin</span></code> over energy would leave the units unchanged at [mb/sr/meV/f.u.].</p>
<p>However, an <code class="docutils literal notranslate"><span class="pre">Integration</span></code> over <span class="math">|Q|</span> instead of energy will yield units of
[mb/Å/sr/meV/f.u.] rather [mb/meV/f.u.] and as such it may be more useful to perform an
average <code class="docutils literal notranslate"><span class="pre">Rebin</span></code> which will leave the units unchanged.</p>
<p>Unfortunately, the input files read by MSlice do not indicate if the signal values saved
are in absolute units or not, so MSlice cannot automatically display the correct units on plots
- this is left to the user.</p>
</section>
<section id="a-note-on-the-regions-of-validity-of-the-two-algorithms">
<h2><span class="section-number">5.6. </span>A note on the regions of validity of the two algorithms<a class="headerlink" href="#a-note-on-the-regions-of-validity-of-the-two-algorithms" title="Link to this heading">¶</a></h2>
<p>As can be seen in the example above, the <code class="docutils literal notranslate"><span class="pre">Integration</span></code> cut algorithm will produce low signals
where there is less data, whereas the <code class="docutils literal notranslate"><span class="pre">Rebin</span></code> cut algorithm will amplify the signals in such
regions. In effect, it assumes that the signal is constant across the integration range and
can be extrapolated over regions without data (so the only manifestation of the lack of data
are larger errorbars associated with these bins).</p>
<p>This assumption <em>may</em> be valid for density-of-states (DOS) type cuts where one would expect
that the signal is approximately constant over <span class="math">|Q|</span> and only varies in energy.
Thus for these applications, it may be suitable to chose the <code class="docutils literal notranslate"><span class="pre">Rebin</span></code> algorithm, and to
extrapolate the high-energy, high-<span class="math">|Q|</span> regions which are kinematically inaccessible.</p>
<p>Conversely, for integration over energy - for example over the elastic line to compute a
differential cross-section or over a finite energy crystal field excitation to obtain a
magnetic cross-section, the <code class="docutils literal notranslate"><span class="pre">Integration</span></code> algorithm should be chosen else the signal
in the cut will vary with the integration range and would not be a cross-section.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">5. Mathematical Reference</a><ul>
<li><a class="reference internal" href="#psd-slice">5.1. PSD Slice</a></li>
<li><a class="reference internal" href="#psd-cut">5.2. PSD Cut</a></li>
<li><a class="reference internal" href="#non-psd-slice">5.3. Non-PSD Slice</a></li>
<li><a class="reference internal" href="#non-psd-cuts">5.4. Non-PSD Cuts</a></li>
<li><a class="reference internal" href="#a-note-on-units">5.5. A note on units</a></li>
<li><a class="reference internal" href="#a-note-on-the-regions-of-validity-of-the-two-algorithms">5.6. A note on the regions of validity of the two algorithms</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="cli.html"
                          title="previous chapter"><span class="section-number">4. </span>Command Line Interface</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/math_ref.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="cli.html" title="4. Command Line Interface"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">MSlice 2.9 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">5. </span>Mathematical Reference</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2021, Mantid Project.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.2.
    </div>
  </body>
</html>