from matplotlib.lines import Line2D
from datetime import datetime
from mslice.cli.helperfunctions import _function_to_intensity

PACKAGES = {'mslice.cli': 'mc', 'mslice.plotting.pyplot': 'plt', 'matplotlib.colors': 'colors'}


def cleanup(script_lines):
    for line in script_lines[-1:]:
        if line.startswith('Load'):
            index = script_lines.index(line)
            return script_lines[index:]


def header(plot_handler):
    statements = ['# Python Script Generated by Mslice on {}\n'.format(datetime.now())]

    for package in PACKAGES:
        if 'colors' in package and plot_handler.colorbar_log is not True:
            continue
        statements.append('import {} as {}\n'.format(package, PACKAGES[package]))

    return statements


def add_header(script_lines, plot_handler):
    for i, statement in enumerate(header(plot_handler)):
        script_lines.insert(i, statement)


def add_plot_statements(script_lines, plot_handler):
    from mslice.plotting.plot_window.slice_plot import SlicePlot
    from mslice.plotting.plot_window.cut_plot import CutPlot

    add_header(script_lines, plot_handler)

    line_no = len(script_lines)
    script_lines.insert(line_no - 1, '\n')
    script_lines[line_no] = 'ws = mc.{}\n'.format(script_lines[line_no])

    if plot_handler is not None:
        if isinstance(plot_handler, SlicePlot):
            add_slice_plot_statements(script_lines, plot_handler)
            add_overplot_statements(script_lines, plot_handler)
        elif isinstance(plot_handler, CutPlot):
            add_cut_plot_statements(script_lines, plot_handler)

        script_lines.append('mc.Show()\n')

    return script_lines


def add_slice_plot_statements(script_lines, plot_handler):
    script_lines.append('slice_ws = mc.Slice(ws)\n\n')
    script_lines.append('fig = plt.gcf()\n')
    script_lines.append('ax = fig.add_subplot(111, projection=\'mslice\')\n')

    if plot_handler.default_options['intensity'] is True:
        intensity = _function_to_intensity[plot_handler.default_options['intensity_method']]
        script_lines.append(
            'mesh = ax.pcolormesh(slice_ws, cmap=\'{}\', intensity=\'{}\', temperature={})\n'.format(
                plot_handler._slice_plotter_presenter._slice_cache[plot_handler.ws_name].colourmap, intensity,
                plot_handler.default_options['temp'] if plot_handler.default_options['temp_dependent'] else None))
    else:
        script_lines.append(
            'mesh = ax.pcolormesh(slice_ws, cmap=\'{}\')\n'.format(
                plot_handler._slice_plotter_presenter._slice_cache[plot_handler.ws_name].colourmap))

    script_lines.append('mesh.set_clim({}, {})\n'.format(*plot_handler.colorbar_range))
    script_lines.append(
        'mesh.set_norm(colors.LogNorm({}, {}))\n'.format(
            0.001 + plot_handler.colorbar_range[0] if plot_handler.colorbar_range[0] == 0 else
            plot_handler.colorbar_range[0], plot_handler.colorbar_range[1]) if plot_handler.colorbar_log is True else ''
    )

    script_lines.append('cb = plt.colorbar(mesh, ax=ax)\n')
    script_lines.append('cb.set_label(\'{}\', labelpad=20, rotation=270, picker=5)\n'.format(
        plot_handler.colorbar_label))

    script_lines.append('ax.set_title(\'{}\')\n'.format(plot_handler.title)
                        if plot_handler.is_changed('title') else '')

    script_lines.append('ax.set_ylabel(\'{}\')\n'.format(plot_handler.y_label)
                        if plot_handler.is_changed('y_label') else '')
    script_lines.append('ax.set_xlabel(\'{}\')\n'.format(plot_handler.x_label)
                        if plot_handler.is_changed('x_label') else '')

    script_lines.append('ax.grid({}, axis=\'y\')\n'.format(plot_handler.y_grid)
                        if plot_handler.is_changed('y_grid') else '')
    script_lines.append('ax.grid({}, axis=\'x\')\n'.format(plot_handler.x_grid)
                        if plot_handler.is_changed('x_grid') else '')

    script_lines.append('ax.set_ylim(bottom={}, top={})\n'.format(*plot_handler.y_range)
                        if plot_handler.is_changed('y_range') else '')
    script_lines.append('ax.set_xlim(left={}, right={})\n'.format(*plot_handler.x_range)
                        if plot_handler.is_changed('x_range') else '')


def add_overplot_statements(script_lines, plot_handler):
    ax = plot_handler._canvas.figure.gca()
    line_artists = [artist for artist in ax.get_children() if isinstance(artist, Line2D)]

    for line in line_artists:
        label = line._label
        key = 1 if label == 'Hydrogen' else 2 if label == 'Deuterium' else 4 if label == 'Helium' else label
        rmm = int(label.split()[-1]) if "Relative" in label else None
        element = label if rmm is None else None
        recoil = True if rmm is not None or key in [1, 2, 4] else False

        if recoil:
            if element is None:
                script_lines.append(
                    'ax.recoil(workspace=\'{}\', element={}, rmm={})\n'.format(
                        plot_handler.ws_name, element, rmm))  # Does not yet account for CIF files
            else:
                script_lines.append(
                    'ax.recoil(workspace=\'{}\', element=\'{}\', rmm={})\n'.format(
                        plot_handler.ws_name, element, rmm))
        else:
            script_lines.append(
                'ax.bragg(workspace=\'{}\', element=\'{}\', cif={})\n'.format(
                    plot_handler.ws_name, element, None))


def add_cut_plot_statements(script_lines, plot_handler):
    script_lines.append('cut_ws = mc.Cut(ws)')
    script_lines.append('ax.plot(cut_ws)')

    script_lines.append('ax.set_title(\'{}\')\n'.format(plot_handler.title))

    script_lines.append('ax.set_ylabel(\'{}\')\n'.format(plot_handler.y_label))
    script_lines.append('ax.set_xlabel(\'{}\')\n'.format(plot_handler.x_label))

    script_lines.append('ax.grid({}, axis=\'y\')\n'.format(plot_handler.y_grid))
    script_lines.append('ax.grid({}, axis=\'x\')\n'.format(plot_handler.x_grid))

    script_lines.append('ax.set_ylim(left={}, right={})\n'.format(*plot_handler.y_range))
    script_lines.append('ax.set_xlim(left={}, right={})\n'.format(*plot_handler.x_range))
